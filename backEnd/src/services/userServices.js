import bcrypt from "bcrypt";
import crypto from "crypto";
import jwt from "jsonwebtoken";
import { sendMail } from "../config/mailer.js";
import userRepository from "../repositories/userRepository.js";

const register = async (userData) => {
  const existing = await userRepository.findByEmail(userData.email);
  if (existing) throw new Error("User already exists");

  // Hash password tr∆∞·ªõc khi l∆∞u v√†o database
  userData.password_hash = await bcrypt.hash(userData.password, 10);
  userData.fullName = `${userData.firstName} ${userData.lastName}`;

  return await userRepository.createUser(userData);
};

const login = async (email, password) => {
  const user = await userRepository.findByEmail(email);
  if (!user) throw new Error("Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i");
  if (!password || !user.password_hash) {
    throw new Error("Thi·∫øu m·∫≠t kh·∫©u ho·∫∑c hash ƒë·ªÉ ki·ªÉm tra!");
  }
  // So s√°nh m·∫≠t kh·∫©u v·ªõi hash
  const isMatch = await bcrypt.compare(password, user.password_hash);
  if (!isMatch) throw new Error("M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng!");
  // T·∫°o JWT token
  const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, {
    expiresIn: "1d",
  });
  const { password_hash, ...safeUser } = user.toObject();

  return { token, user: safeUser };
};

// X√°c th·ª±c t√†i kho·∫£n b·∫±ng token
const getAuthUser = async (userId) => {
  try {
    const user = await userRepository.findById(userId);
    return user;
  } catch (error) {
    console.error("üö® L·ªói trong getAuthUser:", error);
    throw new Error("L·ªói khi l·∫•y th√¥ng tin ng∆∞·ªùi d√πng");
  }
};

// ‚úÖ C·∫≠p nh·∫≠t h·ªì s∆° ng∆∞·ªùi d√πng
const updateUserProfile = async (userId, updateData) => {
  return await userRepository.updateUser(userId, updateData);
};

// ‚úÖ L·∫•y danh s√°ch ƒë·∫∑t ph√≤ng c·ªßa ng∆∞·ªùi d√πng
const getUserBookings = async (userId) => {
  return await userRepository.findBookingsByUserId(userId);
};

// ‚úÖ L·∫•y ph∆∞∆°ng th·ª©c thanh to√°n c·ªßa ng∆∞·ªùi d√πng
const getUserPayments = async (userId) => {
  return await userRepository.getUserPaymentMethods(userId);
};

const forgotPassword = async (email) => {
  const user = await userRepository.findByEmail(email);

  if (!user) {
    throw new Error("Email kh√¥ng t·ªìn t·∫°i.");
  }

  // T·∫°o m·∫≠t kh·∫©u m·ªõi ng·∫´u nhi√™n
  const newPassword = crypto.randomBytes(6).toString("hex");

  // Hash m·∫≠t kh·∫©u m·ªõi tr∆∞·ªõc khi l∆∞u v√†o database
  const hashedPassword = await bcrypt.hash(newPassword, 10);

  // G·ªçi repository ƒë·ªÉ c·∫≠p nh·∫≠t m·∫≠t kh·∫©u ƒë√£ hash v√†o database
  await userRepository.updateUserPassword(email, hashedPassword);

  const subject = "Kh√¥i ph·ª•c m·∫≠t kh·∫©u";
  const text = `M·∫≠t kh·∫©u m·ªõi c·ªßa b·∫°n l√†: ${newPassword}`;

  // G·ª≠i email ch·ª©a m·∫≠t kh·∫©u m·ªõi cho ng∆∞·ªùi d√πng
  await sendMail(email, subject, text);

  return "M·∫≠t kh·∫©u m·ªõi ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n.";
};

export default {
  register,
  login,
  getUserPayments,
  getAuthUser,
  getUserBookings,
  updateUserProfile,
  forgotPassword,
};
